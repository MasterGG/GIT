/* 
 * Command line: opannotate -x --source ./aes_gcm 
 * 
 * Interpretation of command line:
 * Output annotated source file with samples
 * Output all files
 * 
 * CPU: Intel Haswell microarchitecture, speed 2.601e+06 MHz (estimated)
 * Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (No unit mask) count 100000
 */
/* 
 * Total samples for file : "test_aes.c"
 * 
 *  66235 82.5471
 */

<credited to line zero>  66235 82.5471 :
               :#include <string.h>
               :#include <time.h>
               :#include <wmmintrin.h> 
               :#include <emmintrin.h> 
               :#include <smmintrin.h> 
               :#include <stdint.h> 
               :#include <stdio.h>
               :#include <time.h>
               :#define __USE_GNU
               :#define _GNU_SOURCE
               :#include <sched.h>
               :#include <sys/time.h>
               :#include <stdlib.h>
               :#define CORE_NUMBER 3
               :#define check 0 
               :typedef struct KEY_SCHEDULE { 
               :	 unsigned char KEY[16*15]; 
               :	unsigned int nr; 
               :} AES_KEY;
               :void AES_128_Key_Expansion (const uint8_t *userkey, AES_KEY *key);
               :int AES_GCM_decrypt (const unsigned char *in, 
               :	unsigned char *out, 
               :	const unsigned char* addt, 
               :	const unsigned char* ivec, 
               :	unsigned char *tag, 
               :	int nbytes, int abytes, int ibytes, 
               :	const unsigned char* key, 
               :	int nr); 
               :void AES_GCM_encrypt(const unsigned char *in, unsigned char *out, const unsigned char* addt, const unsigned char* ivec, unsigned char *tag, int nbytes, int abytes, int ibytes, const unsigned char* key, int nr); 
               :static void RAND_bytes(unsigned char *dst,int n)
               :{
               :	static int first = 1;
               :	if(first)
               :	{
               :		srand(time(0));
               :		first = 0;
               :	}
               :	for(int i=0;i<n;i++)
               :	{
               :		dst[i] = rand()%256;
               :	}
               :	return;
               :}
               :double time_substract(struct timeval *begin,struct timeval *end)
               :{
               :	return (end->tv_sec - begin->tv_sec)+(end->tv_usec - begin->tv_usec)/1000000.0;
               :}
               :
               :int main()
               :{
               :	cpu_set_t mask;
               :	/* CPU_ZERO initializes all the bits in the mask to zero. */
               :	CPU_ZERO( &mask );
               :	/* CPU_SET sets only the bit corresponding to cpu. */
               :	CPU_SET( CORE_NUMBER, &mask );
               :	/* sched_setaffinity returns 0 in success */
               :	if( sched_setaffinity( 0, sizeof(mask), &mask ) == -1 )
               :	{
               :		printf("WARNING: Could not set CPU Affinity, continuing...\n");
               :	}
               :	printf("== core binding ==\n  binding to core %d ...\n\n", CORE_NUMBER);
               :
               :
               :	struct timeval s1,s2,s3;
               :	int N = 1024*1024*1024;
               :	//int N = 1024;
               ://	int M = 20;
               :	int M = 12;
               :	int I = 12;
               :	//1G Bytes data
               :	uint8_t* P = (uint8_t*)malloc(N);
               :	uint8_t* C = (uint8_t*)malloc(N);
               :	uint8_t* DECRYPTED_TEXT = (uint8_t*)malloc(N);
               :	__m128i T;
               :	RAND_bytes((uint8_t *)P, N);
               :	uint8_t K[16]={0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08};
               :	uint8_t IV[12]={0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad,0xde,0xca,0xf8,0x88}; 
               ://	uint8_t A[20]={0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xab,0xad,0xda,0xd2}; 
               :	uint8_t A[12]={0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce};
               :	AES_KEY key; 
               :	gettimeofday(&s1,0);
               :	AES_128_Key_Expansion (K, key.KEY); 
               :	key.nr = 10; 
               :	for(int i=0;i<N;i+=1024)
               :	{
               :		AES_GCM_encrypt(P+i, C+i, A, IV, &T, 1024, M, I, key.KEY, key.nr); 
               :#if check
               :		if(AES_GCM_decrypt(C+i, DECRYPTED_TEXT+i, A, IV, &T, 1024, M, I, key.KEY, key.nr)!=1)
               :		{
               :			printf("decrypt failed!\n");
               :			printf("%d\n",i);
               :			return -1;
               :		}
               :		for(int j=i; j<i+1024; j++)
               :			if(P[j]!=DECRYPTED_TEXT[j])
               :			{
               :				printf("decrpt data is not equal to the original data! %d\n",i);
               :				return;
               :			}
               :	}
               :	printf("decrpt data is equal to the original data\n");
               :#else
               :	}
               :	gettimeofday(&s2,0);
               :	double t1 = time_substract(&s1,&s2);
               :	printf("  Total time : %lf s\n",t1);
               :	printf("  Speed of encryption: %lf Gbps\n",(8.0*N/t1)/1024/1024/1024);
               :#endif
               :}
/* 
 * Total samples for file : "/usr/share/gcc-5.4.0/lib/gcc/x86_64-unknown-linux-gnu/5.4.0/include/wmmintrin.h"
 * 
 *     66  0.0823
 */


               :/* Copyright (C) 2008-2015 Free Software Foundation, Inc.
               :
               :   This file is part of GCC.
               :
               :   GCC is free software; you can redistribute it and/or modify
               :   it under the terms of the GNU General Public License as published by
               :   the Free Software Foundation; either version 3, or (at your option)
               :   any later version.
               :
               :   GCC is distributed in the hope that it will be useful,
               :   but WITHOUT ANY WARRANTY; without even the implied warranty of
               :   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
               :   GNU General Public License for more details.
               :
               :   Under Section 7 of GPL version 3, you are granted additional
               :   permissions described in the GCC Runtime Library Exception, version
               :   3.1, as published by the Free Software Foundation.
               :
               :   You should have received a copy of the GNU General Public License and
               :   a copy of the GCC Runtime Library Exception along with this program;
               :   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
               :   <http://www.gnu.org/licenses/>.  */
               :
               :/* Implemented from the specification included in the Intel C++ Compiler
               :   User Guide and Reference, version 10.1.  */
               :
               :#ifndef _WMMINTRIN_H_INCLUDED
               :#define _WMMINTRIN_H_INCLUDED
               :
               :/* We need definitions from the SSE2 header file.  */
               :#include <emmintrin.h>
               :
               :/* AES */
               :
               :#ifndef __AES__
               :#pragma GCC push_options
               :#pragma GCC target("aes")
               :#define __DISABLE_AES__
               :#endif /* __AES__ */
               :
               :/* Performs 1 round of AES decryption of the first m128i using 
               :   the second m128i as a round key.  */
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_aesdec_si128 (__m128i __X, __m128i __Y)
               :{
               :  return (__m128i) __builtin_ia32_aesdec128 ((__v2di)__X, (__v2di)__Y);
               :}
               :
               :/* Performs the last round of AES decryption of the first m128i 
               :   using the second m128i as a round key.  */
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_aesdeclast_si128 (__m128i __X, __m128i __Y)
               :{
               :  return (__m128i) __builtin_ia32_aesdeclast128 ((__v2di)__X,
               :						 (__v2di)__Y);
               :}
               :
               :/* Performs 1 round of AES encryption of the first m128i using 
               :   the second m128i as a round key.  */
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_aesenc_si128 (__m128i __X, __m128i __Y)
               :{
               :  return (__m128i) __builtin_ia32_aesenc128 ((__v2di)__X, (__v2di)__Y);
               :}
               :
               :/* Performs the last round of AES encryption of the first m128i
               :   using the second m128i as a round key.  */
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_aesenclast_si128 (__m128i __X, __m128i __Y)
               :{
    66  0.0823 :  return (__m128i) __builtin_ia32_aesenclast128 ((__v2di)__X, (__v2di)__Y);
               :}
               :
               :/* Performs the InverseMixColumn operation on the source m128i 
               :   and stores the result into m128i destination.  */
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_aesimc_si128 (__m128i __X)
               :{
               :  return (__m128i) __builtin_ia32_aesimc128 ((__v2di)__X);
               :}
               :
               :/* Generates a m128i round key for the input m128i AES cipher key and
               :   byte round constant.  The second parameter must be a compile time
               :   constant.  */
               :#ifdef __OPTIMIZE__
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_aeskeygenassist_si128 (__m128i __X, const int __C)
               :{
               :  return (__m128i) __builtin_ia32_aeskeygenassist128 ((__v2di)__X, __C);
               :}
               :#else
               :#define _mm_aeskeygenassist_si128(X, C)					\
               :  ((__m128i) __builtin_ia32_aeskeygenassist128 ((__v2di)(__m128i)(X),	\
               :						(int)(C)))
               :#endif
               :
               :#ifdef __DISABLE_AES__
               :#undef __DISABLE_AES__
               :#pragma GCC pop_options
               :#endif /* __DISABLE_AES__ */
               :
               :/* PCLMUL */
               :
               :#ifndef __PCLMUL__
               :#pragma GCC push_options
               :#pragma GCC target("pclmul")
               :#define __DISABLE_PCLMUL__
               :#endif /* __PCLMUL__ */
               :
               :/* Performs carry-less integer multiplication of 64-bit halves of
               :   128-bit input operands.  The third parameter inducates which 64-bit
               :   haves of the input parameters v1 and v2 should be used. It must be
               :   a compile time constant.  */
               :#ifdef __OPTIMIZE__
               :extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
               :_mm_clmulepi64_si128 (__m128i __X, __m128i __Y, const int __I)
               :{
               :  return (__m128i) __builtin_ia32_pclmulqdq128 ((__v2di)__X,
               :						(__v2di)__Y, __I);
               :}
               :#else
               :#define _mm_clmulepi64_si128(X, Y, I)					\
               :  ((__m128i) __builtin_ia32_pclmulqdq128 ((__v2di)(__m128i)(X),		\
               :					  (__v2di)(__m128i)(Y), (int)(I)))
               :#endif
               :
               :#ifdef __DISABLE_PCLMUL__
               :#undef __DISABLE_PCLMUL__
               :#pragma GCC pop_options
               :#endif /* __DISABLE_PCLMUL__ */
               :
               :#endif /* _WMMINTRIN_H_INCLUDED */
